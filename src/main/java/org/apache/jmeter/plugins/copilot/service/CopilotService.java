/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.jmeter.plugins.copilot.service;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.github.copilot.sdk.CopilotClient;
import com.github.copilot.sdk.CopilotSession;
import com.github.copilot.sdk.SystemMessageMode;
import com.github.copilot.sdk.events.AbstractSessionEvent;
import com.github.copilot.sdk.events.AssistantMessageEvent;
import com.github.copilot.sdk.events.SessionErrorEvent;
import com.github.copilot.sdk.events.SessionIdleEvent;
import com.github.copilot.sdk.events.ToolExecutionCompleteEvent;
import com.github.copilot.sdk.json.CopilotClientOptions;
import com.github.copilot.sdk.json.MessageOptions;
import com.github.copilot.sdk.json.SessionConfig;
import com.github.copilot.sdk.json.SystemMessageConfig;
import com.github.copilot.sdk.json.ToolDefinition;

/**
 * Service class that handles communication with GitHub Copilot
 * using the Copilot SDK for Java.
 */
public class CopilotService {

    private static final Logger log = LoggerFactory.getLogger(CopilotService.class);

    private static final String SYSTEM_MESSAGE = """
        You are a JMeter test generation assistant integrated into Apache JMeter.
        Your role is to help users create JMeter test plans through natural language conversation.
        
        When the user describes a test they want to create, you should:
        1. Understand their testing requirements
        2. Ask clarifying questions if needed
        3. Use the generate_jmeter_test tool to create a COMPLETE JMeter test plan
        
        IMPORTANT: Always generate a COMPLETE, valid JMeter test plan XML that includes:
        - The XML declaration and jmeterTestPlan root element
        - A TestPlan element
        - Proper hashTree structure (every element MUST be followed by a <hashTree> or <hashTree/>)
        - All requested elements (Thread Groups, Samplers, Assertions, etc.)
        
        Example of a complete JMeter test plan:
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <jmeterTestPlan version="1.2" properties="5.0" jmeter="5.6.3">
          <hashTree>
            <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="My Test Plan" enabled="true">
              <stringProp name="TestPlan.comments">Generated by Copilot</stringProp>
              <boolProp name="TestPlan.functional_mode">false</boolProp>
              <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
              <elementProp name="TestPlan.user_defined_variables" elementType="Arguments">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
            </TestPlan>
            <hashTree>
              <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Users" enabled="true">
                <stringProp name="ThreadGroup.num_threads">10</stringProp>
                <stringProp name="ThreadGroup.ramp_time">5</stringProp>
                <elementProp name="ThreadGroup.main_controller" elementType="LoopController">
                  <boolProp name="LoopController.continue_forever">false</boolProp>
                  <stringProp name="LoopController.loops">1</stringProp>
                </elementProp>
              </ThreadGroup>
              <hashTree>
                <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="HTTP Request" enabled="true">
                  <stringProp name="HTTPSampler.domain">example.com</stringProp>
                  <stringProp name="HTTPSampler.port">443</stringProp>
                  <stringProp name="HTTPSampler.protocol">https</stringProp>
                  <stringProp name="HTTPSampler.path">/api/test</stringProp>
                  <stringProp name="HTTPSampler.method">GET</stringProp>
                  <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
                  <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                </HTTPSamplerProxy>
                <hashTree/>
              </hashTree>
            </hashTree>
          </hashTree>
        </jmeterTestPlan>
        ```
        
        Key rules for valid JMeter XML:
        1. Every element (TestPlan, ThreadGroup, HTTPSamplerProxy, etc.) MUST be followed by a <hashTree> tag
        2. Child elements go INSIDE the parent's hashTree
        3. Elements with no children use <hashTree/> (self-closing)
        4. The structure is: Element -> hashTree -> (child elements with their own hashTrees)
        
        Always explain what you're creating and why. Be helpful and guide users
        through creating effective load tests.
        """;

    private CopilotClient client;
    private CopilotSession session;
    private final StringBuilder generatedXmlBuilder = new StringBuilder();

    /**
     * Creates a new CopilotService instance.
     */
    public CopilotService() {
        // Client will be initialized lazily on first use
    }

    // Progress callback for UI updates
    private Consumer<String> progressCallback;

    /**
     * Set a callback for progress updates.
     */
    public void setProgressCallback(Consumer<String> callback) {
        this.progressCallback = callback;
    }

    private void reportProgress(String message) {
        System.out.println("[JMeter Copilot] " + message);
        log.info(message);
        if (progressCallback != null) {
            progressCallback.accept(message);
        }
    }

    /**
     * Initialize the Copilot client and session.
     */
    private synchronized void ensureInitialized(String model) throws Exception {
        if (client == null) {
            reportProgress("Starting Copilot client...");
            client = new CopilotClient(
                new CopilotClientOptions()
                    .setAutoStart(true)
                    .setAutoRestart(true)
            );
            client.start().get();
            reportProgress("Copilot client started successfully");
        }

        if (session == null) {
            reportProgress("Creating session with model: " + model + "...");
            session = client.createSession(
                new SessionConfig()
                    .setModel(model)
                    .setSystemMessage(new SystemMessageConfig()
                        .setMode(SystemMessageMode.APPEND)
                        .setContent(SYSTEM_MESSAGE))
                    .setTools(List.of(createJMeterTestTool()))
                    .setStreaming(false)
            ).get();
            reportProgress("Session created, ready to chat!");
        }
    }

    /**
     * Create the JMeter test generation tool definition.
     * This tool accepts raw JMeter XML from Copilot.
     */
    private ToolDefinition createJMeterTestTool() {
        Map<String, Object> toolSchema = Map.of(
            "type", "object",
            "properties", Map.of(
                "xml", Map.of(
                    "type", "string",
                    "description", "A COMPLETE JMeter test plan XML starting with <?xml and <jmeterTestPlan>. Must include proper hashTree structure."
                ),
                "description", Map.of(
                    "type", "string",
                    "description", "A brief description of what this test plan does"
                )
            ),
            "required", List.of("xml", "description")
        );

        return ToolDefinition.create(
            "generate_jmeter_test",
            "Generate a COMPLETE JMeter test plan XML. The XML must start with <?xml and include the full jmeterTestPlan structure with proper hashTree elements.",
            toolSchema,
            invocation -> {
                try {
                    System.out.println("[JMeter Copilot] TOOL INVOKED - Processing complete test plan...");
                    Object args = invocation.getArguments();
                    
                    String xml = null;
                    String description = null;
                    
                    // Handle Jackson ObjectNode (from Copilot SDK)
                    if (args instanceof com.fasterxml.jackson.databind.JsonNode jsonNode) {
                        xml = jsonNode.has("xml") ? jsonNode.get("xml").asText() : null;
                        description = jsonNode.has("description") ? jsonNode.get("description").asText() : null;
                    } else if (args instanceof Map) {
                        @SuppressWarnings("unchecked")
                        Map<String, Object> argsMap = (Map<String, Object>) args;
                        xml = (String) argsMap.get("xml");
                        description = (String) argsMap.get("description");
                    }
                    
                    System.out.println("[JMeter Copilot] Generated test plan: " + description);
                    System.out.println("[JMeter Copilot] XML length: " + (xml != null ? xml.length() : 0) + " chars");
                    
                    // Validate it looks like a complete test plan
                    if (xml != null && xml.contains("<jmeterTestPlan")) {
                        System.out.println("[JMeter Copilot] ✓ Valid complete test plan detected");
                    } else {
                        System.out.println("[JMeter Copilot] ⚠ Warning: XML may not be a complete test plan");
                    }
                    
                    log.info("Generated JMeter test plan: {}", description);
                    
                    // Store the complete XML (replaces any previous)
                    if (xml != null && !xml.isEmpty()) {
                        synchronized (generatedXmlBuilder) {
                            generatedXmlBuilder.setLength(0);
                            generatedXmlBuilder.append(xml);
                        }
                    }
                    
                    return CompletableFuture.completedFuture(
                        "Successfully generated complete JMeter test plan: " + description
                    );
                } catch (Exception e) {
                    System.err.println("[JMeter Copilot] ERROR in tool handler: " + e.getMessage());
                    e.printStackTrace();
                    log.error("Failed to generate JMeter test plan", e);
                    return CompletableFuture.completedFuture(
                        "Error generating test plan: " + e.getMessage()
                    );
                }
            }
        );
    }

    /**
     * Send a message to Copilot and get a response.
     *
     * @param message The user's message
     * @param model The AI model to use
     * @return A CompletableFuture with the response
     */
    public CompletableFuture<CopilotResponse> sendMessageAsync(String message, String model) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                ensureInitialized(model);
                
                // Clear any previously generated XML
                synchronized (generatedXmlBuilder) {
                    generatedXmlBuilder.setLength(0);
                }

                reportProgress("Sending message to Copilot...");
                
                CompletableFuture<String> responseFuture = new CompletableFuture<>();
                StringBuilder responseBuilder = new StringBuilder();
                CompletableFuture<Void> done = new CompletableFuture<>();

                session.on(event -> handleSessionEvent(event, responseBuilder, done, responseFuture));

                session.send(new MessageOptions().setPrompt(message)).get();
                reportProgress("Waiting for Copilot response...");
                done.get();

                String responseText = responseFuture.getNow(responseBuilder.toString());
                
                // Get accumulated XML
                String generatedXml;
                synchronized (generatedXmlBuilder) {
                    generatedXml = generatedXmlBuilder.length() > 0 ? generatedXmlBuilder.toString() : null;
                }
                
                System.out.println("[JMeter Copilot] Final generated XML: " + (generatedXml != null ? generatedXml.length() + " chars" : "null"));

                reportProgress("Response received!");
                return new CopilotResponse(responseText, generatedXml);
            } catch (Exception e) {
                String errorMsg = "Failed to communicate with Copilot: " + e.getMessage();
                System.err.println("[JMeter Copilot] ERROR: " + errorMsg);
                e.printStackTrace();
                log.error("Failed to send message to Copilot", e);
                throw new RuntimeException(errorMsg, e);
            }
        });
    }

    /**
     * Handle session events from Copilot.
     */
    private void handleSessionEvent(
            AbstractSessionEvent event,
            StringBuilder responseBuilder,
            CompletableFuture<Void> done,
            CompletableFuture<String> responseFuture) {
        
        String eventType = event.getClass().getSimpleName();
        System.out.println("[JMeter Copilot] Event: " + eventType);
        log.debug("Received event: {}", eventType);
        
        if (event instanceof AssistantMessageEvent msg) {
            String content = msg.getData().getContent();
            if (content != null) {
                System.out.println("[JMeter Copilot] Assistant response received (" + content.length() + " chars)");
                responseBuilder.append(content);
                responseFuture.complete(content);
            }
        } else if (event instanceof ToolExecutionCompleteEvent toolEvent) {
            System.out.println("[JMeter Copilot] Tool execution complete!");
            reportProgress("Generated JMeter element...");
            log.info("Tool execution complete: {}", toolEvent.getData());
        } else if (event instanceof SessionErrorEvent err) {
            String errorMsg = err.getData().getMessage();
            System.err.println("[JMeter Copilot] Session error: " + errorMsg);
            log.error("Session error: {}", errorMsg);
            responseFuture.completeExceptionally(new RuntimeException(errorMsg));
            done.complete(null);
        } else if (event instanceof SessionIdleEvent) {
            System.out.println("[JMeter Copilot] Session idle - processing complete");
            done.complete(null);
        }
    }

    /**
     * Reset the current session.
     */
    public void resetSession() {
        if (session != null) {
            try {
                session.close();
            } catch (Exception e) {
                log.warn("Error closing session", e);
            }
            session = null;
        }
        synchronized (generatedXmlBuilder) {
            generatedXmlBuilder.setLength(0);
        }
    }

    /**
     * Shutdown the Copilot client and release resources.
     */
    public void shutdown() {
        resetSession();
        if (client != null) {
            try {
                client.stop().get();
                client.close();
            } catch (Exception e) {
                log.warn("Error shutting down Copilot client", e);
            }
            client = null;
        }
    }

    /**
     * Response from Copilot including the message and any generated test plan.
     */
    public static class CopilotResponse {
        private final String message;
        private final String testPlanXml;

        public CopilotResponse(String message, String testPlanXml) {
            this.message = message;
            this.testPlanXml = testPlanXml;
        }

        public String getMessage() {
            return message;
        }

        public String getTestPlanXml() {
            return testPlanXml;
        }

        public boolean hasGeneratedTestPlan() {
            return testPlanXml != null && !testPlanXml.isEmpty();
        }
    }
}
